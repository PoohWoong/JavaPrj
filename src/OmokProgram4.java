/*오목4. 승패 체크를 전수조사하는 방식을 통해서 한다.
아직 그 외 룰은 체크하지 않는다.*/

import java.util.Scanner;

public class OmokProgram4 {

	public static void main(String[] args) {
		
		Scanner scan= new Scanner(System.in);

		int width=21; //바둑판의 크기
		int height=width; //바둑판은 정방행렬이 되어야 한다.
		char[][] board = new char[height][width]; //바둑판 배열
		int[] omokXs = new int[height*width];
		int[] omokYs = new int[height*width];
		int[] types = new int[height*width];
		
		//좌표를 이용한 테두리 두기
		for(int j=0;j<height;j++)
			for(int i=0; i<width;i++)
				board[j][i]='┼';
		for(int i=0;i<width;i++)
		{
			board[0][i]='┬';
			board[height-1][i]='┴';			
		}
		for(int i=0;i<height;i++)
		{
			board[i][0]='├';
			board[i][width-1]='┤';
		}
		board[0][0]='┌';
		board[0][width-1]='┐';
		board[height-1][0]='└';
		board[height-1][width-1]='┘';
		board[height/2][width/2]='╋';
		
		
		int mapx;
		int mapy;
		int type;
		int count=0;
		
		//바둑판 출력
		for(int y=0; y<height;y++){
			for(int x=0; x<width;x++)
				System.out.printf("%c", board[y][x]);
			System.out.println();
		}
		
		좌표시작:
		while(count<width*height){
			
			type=count%2+1;
						
			//사용자 입력을 받는 로직
			System.out.printf("턴 %d. %s돌 오목 두기 (x sp y): ", count+1, type==1?"흑":"백");
			mapx=scan.nextInt();
			mapy=scan.nextInt();
			//범위 유효성 검사
			if(mapx<1||mapx>width||mapy<1||mapy>height)
				continue 좌표시작;
			//중복검사
			if(board[mapy-1][mapx-1]=='●'||board[mapy-1][mapx-1]=='○')
				continue;
			//입력받은 좌표를 가지고 board배열 자체를 체크하는 방식.
			
						
			omokXs[count]=mapx;
			omokYs[count]=mapy;
			types[count]=type;
			
			if(type==2)
				board[omokYs[count]-1][omokXs[count]-1]='○';
			else
				board[omokYs[count]-1][omokXs[count]-1]='●';
			
			//바둑판 출력
			for(int y=0; y<height;y++){
				for(int x=0; x<width;x++)
					System.out.printf("%c", board[y][x]);
				System.out.println();
			}
			//승패검사 - 좌표에서, 돌을 기준으로 사방을 검사하는 방식으로.
			for(int y=0;y<height;y++)
				for(int x=0;x<width;x++)
					//물론 if문 하나에 모두 묶을 수는 있다. 하지만 그렇게 될 경우 if문의 조건이 한눈에 들어오지가 않는다.
					if(x<width-5&&board[y][x]==board[y][x+1]&&(board[y][x]=='●'||board[y][x]=='○')){
						if(board[y][x]==board[y][x+2])
							if(board[y][x]==board[y][x+3])
								if(board[y][x]==board[y][x+4]){
									System.out.printf("게임끝! %s 승리!\n", board[y][x]=='●'?"흑":"백");
									break 좌표시작;
								}// → 방향의 검사
					}else if(y<height-5&&board[y][x]==board[y+1][x]&&(board[y][x]=='●'||board[y][x]=='○')){
						if(board[y][x]==board[y+2][x])
							if(board[y][x]==board[y+3][x])
								if(board[y][x]==board[y+4][x]){
									System.out.printf("게임끝! %s 승리!\n", board[y][x]=='●'?"흑":"백");
									break 좌표시작;
								} //↓방향의 검사
					}else if(y<height-5&&x<width-5&&board[y][x]==board[y+1][x+1]&&(board[y][x]=='●'||board[y][x]=='○')){
						if(board[y][x]==board[y+2][x+2])
							if(board[y][x]==board[y+3][x+3])
								if(board[y][x]==board[y+4][x+4]){
									System.out.printf("게임끝! %s 승리!\n", board[y][x]=='●'?"흑":"백");
									break 좌표시작;
								} //↘방향의 검사
					}else if(y<height-5&&x>=4&&board[y][x]==board[y+1][x-1]&&(board[y][x]=='●'||board[y][x]=='○')){
						if(board[y][x]==board[y+2][x-2])
							if(board[y][x]==board[y+3][x-3])
								if(board[y][x]==board[y+4][x-4]){
									System.out.printf("게임끝! %s 승리!\n", board[y][x]=='●'?"흑":"백");
									break 좌표시작;
								}// ↙방향의 검사
					}
						
			count++;
			if(count==height*width) //만약 바둑판을 다 채워버리면 무승부
				System.out.println("게임 끝! 무승부!");
		}
		
	}
}
